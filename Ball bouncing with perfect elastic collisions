# imports
import pygame
from math import sqrt
from random import randint


# some variables
SCREEN_WIDTH = 1234
SCREEN_HEIGHT = 124
FPS = 60
BACKGROUND_COLOR = (255, 255, 255)
BALLS_COLOR = (0, 0, 0)
BALLS_SIZE = 40
# max number of balls formula, so they dont bug at the start is: SCREEN_WIDTH or SCREEN_HEIGHT / 1.5 BALL_SIZE - 1
# there is also absolute max, so the program does not crush but it depends on BALLS_SIZE
# for BALLS_SIZE 20 it is 66
NUMBER_OF_BALLS = 3


# ball class
class Ball:

    def __init__(self, x, y, x_speed, y_speed, radius, color):
        self.x = x
        self.y = y
        self.x_speed = x_speed
        self.y_speed = y_speed
        self.radius = radius
        self.color = color

    def draw(self):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)


def collision_check(ball1, ball2):
    # finds distance between two centres of the balls and sum of their radiates
    center_distance = sqrt((ball1.x - ball2.x) ** 2 + (ball1.y - ball2.y) ** 2)
    two_radiates_sum = ball1.radius + ball2.radius
    # returns True when collision and False otherwise
    if center_distance <= two_radiates_sum:
        return True
    else:
        return False


def collision(ball1, ball2):
    # collision calculation
    # 1
    # unit normal vector
    un = [ball1.x - ball2.x, ball1.y - ball2.y]
    # unit tangent vector
    ut = [-un[1], un[0]]
    # 2
    # velocity vector for ball1
    v1 = [ball1.x_speed, ball1.y_speed]
    # velocity vector for ball2
    v2 = [ball2.x_speed, ball2.y_speed]
    # 3
    # vectors to plain numbers
    v1n = (v1[0] * un[0] + v1[1] * un[1]) / (un[0] * un[0] + un[1] * un[1])
    v1t = (v1[0] * ut[0] + v1[1] * ut[1]) / (ut[0] * ut[0] + ut[1] * ut[1])
    v2n = (v2[0] * un[0] + v2[1] * un[1]) / (un[0] * un[0] + un[1] * un[1])
    v2t = (v2[0] * ut[0] + v2[1] * ut[1]) / (ut[0] * ut[0] + ut[1] * ut[1])
    # 4
    # new tangent velocities
    # there is no friction so this step is not necessary
    # 5
    # new normal velocities
    # there are masses in original formulas, so they are left ones as placeholders
    # but because masses are the same it means v1n, v2n = v2n, v1n
    v1n, v2n = (v1n * (1 - 1) + 2 * 1 * v2n) / (1 + 1), (v2n * (1 - 1) + 2 * 1 * v1n) / (1 + 1)
    # 6
    # scalar values to vectors for ball1
    v1n = [v1n * un[0], v1n * un[1]]
    v1t = [v1t * ut[0], v1t * ut[1]]
    # scalar values to vectors for ball2
    v2n = [v2n * un[0], v2n * un[1]]
    v2t = [v2t * ut[0], v2t * ut[1]]
    # 7
    # new velocity vectors
    v1[0] = v1n[0] + v1t[0]
    v1[1] = v1n[1] + v1t[1]
    v2[0] = v2n[0] + v2t[0]
    v2[1] = v2n[1] + v2t[1]
    # assigment to balls
    ball1.x_speed = v1[0]
    ball1.y_speed = v1[1]
    ball2.x_speed = v2[0]
    ball2.y_speed = v2[1]
    # end of collision calculation

    # moving ball1 and ball2 a litte so they dont stuck into each other
    # point of collision
    cx = (ball1.x + ball2.x) / 2
    cy = (ball1.y + ball2.y) / 2
    # distance from collision point to ball1 centre (a bit smaller than radius)
    d = sqrt((ball1.x - cx) ** 2 + (ball1.y - cy) ** 2)
    # distance between point of the collision to ball1 center point in both axes divided by d
    x_speed = (ball1.x - cx) / d
    dy = (ball1.y - cy) / d
    # ball1 move to point of collision + radius time ex or ey
    ball1.x = cx + x_speed * ball1.radius
    ball1.y = cy + dy * ball1.radius
    # ball2 move in opposite direction
    x_speed = -x_speed
    dy = -dy
    ball2.x = cx + x_speed * ball2.radius
    ball2.y = cy + dy * ball2.radius
    return ball1, ball2


def move(ball):
    # moving ball
    ball.x = ball.x + ball.x_speed
    ball.y = ball.y + ball.y_speed
    # checking for wall collision
    if ball.x >= SCREEN_WIDTH - BALLS_SIZE:
        ball.x_speed = -ball.x_speed
        ball.x = SCREEN_WIDTH - BALLS_SIZE - 1
    if ball.x <= BALLS_SIZE:
        ball.x_speed = -ball.x_speed
        ball.x = BALLS_SIZE + 1
    if ball.y >= SCREEN_HEIGHT - BALLS_SIZE:
        ball.y_speed = -ball.y_speed
        ball.y = SCREEN_HEIGHT - BALLS_SIZE - 1
    if ball.y <= BALLS_SIZE:
        ball.y_speed = -ball.y_speed
        ball.y = BALLS_SIZE + 1
    return ball


# writes prompt and creates screen and clock
print('\nAll collision formulas based on article by Chad Berchek "2-Dimensional Elastic Collisions without Trigonometry".')
print('http://www.vobarian.com/collisions/')
pygame.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
clock = pygame.time.Clock()

# creating circles
balls = []
for i in range(NUMBER_OF_BALLS):
    balls.append(Ball(1.5 * BALLS_SIZE + i * 1.5 * BALLS_SIZE, 1.5 * BALLS_SIZE + i * 1.5 * BALLS_SIZE, randint(-5, 5), randint(-5, 5), BALLS_SIZE, BALLS_COLOR))

# main loop
while True:
    # checks if user wants to close the screen
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            exit(0)
    # moves balls and checks if any circle hit the wall
    for element in balls:
        move(element)
    # checks for collisions between balls
    for ball1_index in range(0, len(balls)):
        for ball2_index in range(ball1_index + 1, len(balls)):
            if collision_check(balls[ball1_index], balls[ball2_index]):
                balls[ball1_index], balls[ball2_index] = collision(balls[ball1_index], balls[ball2_index])
                # breaks the second for loop, so the balls wont stuck into each other
                break
    # drawing stuff
    screen.fill(BACKGROUND_COLOR)
    for element in balls:
        element.draw()
    pygame.display.flip()
    clock.tick(FPS)
